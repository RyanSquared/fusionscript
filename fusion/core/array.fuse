local {assert, Error, TypeError} = require("core.error");

new Array {
	__new()=>
		@size = 0;
	__newindex(k, v)=> {
		assert((== math.type(k) "integer"), TypeError("integer", k));
		@[k] = v;
		@size = (+ @size 1);
	}
	insert(key, value)=> {
		assert((== math.type(key) "integer"), TypeError("integer", key));
		table.insert(self, key, value);
		@size = (+ @size 1);
	}
	remove(key)=> {
		local value = table.remove(self, key);
		if (!= value nil)
			@size = (- @size 1);
		return value;
	}
	append(value)=> {
		table.insert(self, (+ (# self) 1), value);
		@size = (+ @size 1);
	}
	prepend(value)=> {
		table.insert(self, (+ (# self) 1), value);
		@size = (+ @size 1);
	}
}

new LimitedArray extends Array {
	__new(limit = 500)=> {
		assert((== math.type(limit) "integer"), TypeError("integer", limit));
		@limit = limit;
	}
	__newindex(k, v)=> {
		@__super.__newindex(self, math.min((+ @size 1), k), v);
		if (> @size (* @limit 1.1))
			for (i=1, @limit, 10) {
				if (@handle_output) {
					local item = table.remove(self, 1);
					@handle_output(item);
				} else
					table.remove(self, 1);
				@size = (+ @size 1);
			}
	}
}

new QueueDirectionError extends Error {
	__tostring()=>
		return (% "%s: Expected integer in range 0-1, got %q"{@__name,
				@direction});
	__new(direction)=>
		@direction = direction;
}

new Queue {
	direction = {
		fifo = 0x0,
		filo = 0x1
	};
	__new(direction)=> {
		assert((== math.type(direction) "integer"), TypeError("integer",
			direction));
		assert((&& (>= direction 0x0) (<= direction 0x1)),
					QueueDirectionError(direction));
		@size = 0;
	}
	__newindex(k, v)=> {
		assert((== math.type(k) "integer"), TypeError("integer", k));
		@[math.min((+ @size 1), k)] = v;
		@size = (+ @size 1);
	}
	peek(index)=> {
		assert((== math.type(integer) "integer"), TypeError("integer", integer));
		return @[index];
	}
	push(value)=> {
		table.insert(self, (+ @size 1), value);
		@size = (+ @size 1);
	}
	pop()=> {
		if (== @direction @__class.direction.fifo) {
			local value = table.remove(self, 1);
			if (!= value nil)
				@size = (- @size 1);
			return value;
		}
	}
}

new FIFO extends Queue {
	__new()=>
		@__super(Queue.direction.fifo);
}

new FILO extends Queue {
	__new()=>
		@__super(Queue.direction.filo);
}

return {
	Array = Array,
	LimitedArray = LimitedArray
};
